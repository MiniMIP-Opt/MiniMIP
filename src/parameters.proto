// Copyright 2023 the MiniMIP Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto2";

package minimip;

message LpParameters {
  // The underlying solver to use. Note that some parameters behave differently
  // depending on the solver type.
  enum SolverType {
    LP_GLOP = 0;
    LP_SOPLEX = 1;
  }
  optional SolverType lp_solver_type = 1 [default = LP_GLOP];

  // Whether to start solving` from scratch. If false, the underlying LP solver
  // will attempt to leverage incrementalism (if possible).
  optional bool solve_from_scratch = 2 [default = false];

  // What kind of scaling the LP solver should use. All solvers may not support
  // all scaling strategies.
  enum ScalingStrategy {
    SCALING_OFF = 0;  // No scaling at all.
    SCALING_DEFAULT = 1;  // LP Solver's default scaling strategy.
    SCALING_EQUILIBRATION = 2;
    SCALING_LEAST_SQUARES = 3;
    SCALING_LINEAR_PROGRAM = 4;
  }
  optional ScalingStrategy scaling_strategy = 3 [default = SCALING_DEFAULT];

  // Should the LP solver use presolving?
  optional bool use_presolve = 4 [default = true];

  // Pricing strategy. All solvers may not support all pricing strategies.
  enum PricingStrategy {
    PRICING_DEFAULT = 0;  // LP solver's default pricing strategy.
    PRICING_STEEPEST_EDGE = 1;
    PRICING_STEEPEST_EDGE_QUICK_START = 2;
    PRICING_DANTZIG = 3;
    PRICING_PARTIAL_DANTZIG = 4;
    PRICING_DEVEX = 5;
  }
  optional PricingStrategy pricing_strategy = 5 [default = PRICING_DEFAULT];

  // Feasibility tolerance for primal variables and slacks (aka just feasibility
  // tolerance). Set to -1 to use LP solver's default tolerance. Must be
  // non-negative or -1.
  optional double feasibility_tolerance = 6 [default = -1.0];

  // Feasibility tolerance for dual variables and slacks (aka optimality
  // tolerance). Set to -1 to use LP solver's default tolerance. Must be
  // non-negative or -1.
  optional double optimality_tolerance = 7 [default = -1.0];

  // Minimal Markowitz threshold in LU factorization. Must be between 0 and 1
  // (or -1 to use LP solver's default), though LP solver may choose to clip
  // the value (e.g., SoPlex requires this to be between 1e-4 and 1 - 1e-4).
  optional double min_markowitz_threshold = 8 [default = -1];

  // Refactorization interval. Set to 0 to let the LP solver determine the
  // refactorization interval automatically. Must be non-negative.
  optional int32 refactorization_interval = 9 [default = 0];

  // The LP solver stops when the objective value gets smaller than this value.
  // Note, LP solver may trim this wrt their definition of infinity.
  optional double objective_lower_limit = 10 [default = -inf];

  // The LP solver stops when the objective value gets larger than this value.
  // Note, LP solver may trim this wrt their definition of infinity.
  optional double objective_upper_limit = 11 [default = inf];

  // Timing mode and limit. Not all solvers support all timing modes.
  // If `timing_mode` is TIMING_OFF, no limit is imposed.
  // Note, LP solver may trim `time_limit` wrt their definition of infinity.
  enum TimingMode {
    TIMING_OFF = 0;
    TIMING_WALLCLOCK = 1;
    TIMING_CPU = 2;
    TIMING_DETERMINISTIC = 3;
  }
  optional TimingMode timing_mode = 12 [default = TIMING_OFF];
  optional double time_limit = 13 [default = inf];

  // Iteration limit for the LP solver. Set to 0 to impose no limit. Must be
  // non-negative.
  optional int32 iteration_limit = 14 [default = 0];

  // Number of thread to use. Set to 0 to let the LP solver determine the number
  // of threads automatically. Must be non-negative.
  optional int32 num_threads = 15 [default = 0];

  // Initial random seed, which may affects e.g. perturbations in the simplex.
  // Set to 0 to use the solver default. Must be non-negative.
  optional int32 random_seed = 16 [default = 0];

  // If true, the solver prints extra debugging information to the console.
  optional bool enable_internal_solver_output = 17 [default = false];
}

message MiniMipParameters {
  // Parameters to forward to the underlying LP solver. These will be used to
  // instantiate the "main" LP solver in MiniMip (i.e., the one used to solve
  // nodes' relaxations while exploring the search tree).
  optional LpParameters lp_parameters = 1;

  // A value v is considered integral within MiniMip if
  // abs(v - round(v)) <= integrality_tolerance.
  optional double integrality_tolerance = 2 [default = 1e-6];

}
